{"content": {"suites": {"0": {"status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}, "tests": {"0": {"status": "ERROR", "message": "self = <selenium.webdriver.chrome.service.Service object at 0x0000019A36BFB350>\npath = 'C:\\\\Users\\\\SR_E93833\\\\.cache\\\\selenium\\\\chromedriver\\\\win64\\\\125.0.6422.78\\\\chromedriver.exe'\n\n    def _start_process(self, path: str) -> None:\n        \"\"\"Creates a subprocess by executing the command provided.\n    \n        :param cmd: full command to execute\n        \"\"\"\n        cmd = [path]\n        cmd.extend(self.command_line_args())\n        close_file_descriptors = self.popen_kw.pop(\"close_fds\", system() != \"Windows\")\n        try:\n            start_info = None\n            if system() == \"Windows\":\n                start_info = subprocess.STARTUPINFO()\n                start_info.dwFlags = subprocess.CREATE_NEW_CONSOLE | subprocess.STARTF_USESHOWWINDOW\n                start_info.wShowWindow = subprocess.SW_HIDE\n    \n>           self.process = subprocess.Popen(\n                cmd,\n                env=self.env,\n                close_fds=close_file_descriptors,\n                stdout=self.log_output,\n                stderr=self.log_output,\n                stdin=PIPE,\n                creationflags=self.creation_flags,\n                startupinfo=start_info,\n                **self.popen_kw,\n            )\n\n..\\..\\..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\selenium\\webdriver\\common\\service.py:208: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py:1026: in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Popen: returncode: None args: ['C:\\\\Users\\\\SR_E93833\\\\.cache\\\\selenium\\\\chr...>\nargs = 'C:\\\\Users\\\\SR_E93833\\\\.cache\\\\selenium\\\\chromedriver\\\\win64\\\\125.0.6422.78\\\\chromedriver.exe --port=56359', executable = None\npreexec_fn = None, close_fds = False, pass_fds = (), cwd = None\nenv = environ({'ALLUSERSPROFILE': 'C:\\\\ProgramData', 'APPDATA': 'C:\\\\Users\\\\SR_E93833\\\\AppData\\\\Roaming', 'CHROME_CRASHPAD_P...23-sock', 'VSCODE_INJECTION': '1', 'PYTEST_VERSION': '8.2.1', 'PYTEST_CURRENT_TEST': 'Asserts_4.py::test_uno (setup)'})\nstartupinfo = <subprocess.STARTUPINFO object at 0x0000019A36127950>, creationflags = 0, shell = False, p2cread = Handle(888)\np2cwrite = 7, c2pread = -1, c2pwrite = Handle(900), errread = -1, errwrite = Handle(904), unused_restore_signals = True\nunused_gid = None, unused_gids = None, unused_uid = None, unused_umask = -1, unused_start_new_session = False, unused_process_group = -1\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       unused_restore_signals,\n                       unused_gid, unused_gids, unused_uid,\n                       unused_umask,\n                       unused_start_new_session, unused_process_group):\n        \"\"\"Execute program (MS Windows version)\"\"\"\n    \n        assert not pass_fds, \"pass_fds not supported on Windows.\"\n    \n        if isinstance(args, str):\n            pass\n        elif isinstance(args, bytes):\n            if shell:\n                raise TypeError('bytes args is not allowed on Windows')\n            args = list2cmdline([args])\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = list2cmdline([args])\n        else:\n            args = list2cmdline(args)\n    \n        if executable is not None:\n            executable = os.fsdecode(executable)\n    \n        # Process startup details\n        if startupinfo is None:\n            startupinfo = STARTUPINFO()\n        else:\n            # bpo-34044: Copy STARTUPINFO since it is modified above,\n            # so the caller can reuse it multiple times.\n            startupinfo = startupinfo.copy()\n    \n        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)\n        if use_std_handles:\n            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES\n            startupinfo.hStdInput = p2cread\n            startupinfo.hStdOutput = c2pwrite\n            startupinfo.hStdError = errwrite\n    \n        attribute_list = startupinfo.lpAttributeList\n        have_handle_list = bool(attribute_list and\n                                \"handle_list\" in attribute_list and\n                                attribute_list[\"handle_list\"])\n    \n        # If we were given an handle_list or need to create one\n        if have_handle_list or (use_std_handles and close_fds):\n            if attribute_list is None:\n                attribute_list = startupinfo.lpAttributeList = {}\n            handle_list = attribute_list[\"handle_list\"] = \\\n                list(attribute_list.get(\"handle_list\", []))\n    \n            if use_std_handles:\n                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]\n    \n            handle_list[:] = self._filter_handle_list(handle_list)\n    \n            if handle_list:\n                if not close_fds:\n                    warnings.warn(\"startupinfo.lpAttributeList['handle_list'] \"\n                                  \"overriding close_fds\", RuntimeWarning)\n    \n                # When using the handle_list we always request to inherit\n                # handles but the only handles that will be inherited are\n                # the ones in the handle_list\n                close_fds = False\n    \n        if shell:\n            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW\n            startupinfo.wShowWindow = _winapi.SW_HIDE\n            if not executable:\n                # gh-101283: without a fully-qualified path, before Windows\n                # checks the system directories, it first looks in the\n                # application directory, and also the current directory if\n                # NeedCurrentDirectoryForExePathW(ExeName) is true, so try\n                # to avoid executing unqualified \"cmd.exe\".\n                comspec = os.environ.get('ComSpec')\n                if not comspec:\n                    system_root = os.environ.get('SystemRoot', '')\n                    comspec = os.path.join(system_root, 'System32', 'cmd.exe')\n                    if not os.path.isabs(comspec):\n                        raise FileNotFoundError('shell not found: neither %ComSpec% nor %SystemRoot% is set')\n                if os.path.isabs(comspec):\n                    executable = comspec\n            else:\n                comspec = executable\n    \n            args = '{} /c \"{}\"'.format (comspec, args)\n    \n        if cwd is not None:\n            cwd = os.fsdecode(cwd)\n    \n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n    \n        # Start the process\n        try:\n>           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,\n                                     # no special security\n                                     None, None,\n                                     int(not close_fds),\n                                     creationflags,\n                                     env,\n                                     cwd,\n                                     startupinfo)\nE                                    PermissionError: [WinError 5] Access is denied\n\n..\\..\\..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py:1538: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.fixture(scope='module')\n    def setup_login():\n        global driver, f\n>       driver = webdriver.Chrome()\n\nAsserts_4.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\selenium\\webdriver\\chrome\\webdriver.py:45: in __init__\n    super().__init__(\n..\\..\\..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\selenium\\webdriver\\chromium\\webdriver.py:50: in __init__\n    self.service.start()\n..\\..\\..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\selenium\\webdriver\\common\\service.py:98: in start\n    self._start_process(self._path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <selenium.webdriver.chrome.service.Service object at 0x0000019A36BFB350>\npath = 'C:\\\\Users\\\\SR_E93833\\\\.cache\\\\selenium\\\\chromedriver\\\\win64\\\\125.0.6422.78\\\\chromedriver.exe'\n\n    def _start_process(self, path: str) -> None:\n        \"\"\"Creates a subprocess by executing the command provided.\n    \n        :param cmd: full command to execute\n        \"\"\"\n        cmd = [path]\n        cmd.extend(self.command_line_args())\n        close_file_descriptors = self.popen_kw.pop(\"close_fds\", system() != \"Windows\")\n        try:\n            start_info = None\n            if system() == \"Windows\":\n                start_info = subprocess.STARTUPINFO()\n                start_info.dwFlags = subprocess.CREATE_NEW_CONSOLE | subprocess.STARTF_USESHOWWINDOW\n                start_info.wShowWindow = subprocess.SW_HIDE\n    \n            self.process = subprocess.Popen(\n                cmd,\n                env=self.env,\n                close_fds=close_file_descriptors,\n                stdout=self.log_output,\n                stderr=self.log_output,\n                stdin=PIPE,\n                creationflags=self.creation_flags,\n                startupinfo=start_info,\n                **self.popen_kw,\n            )\n            logger.debug(\n                \"Started executable: `%s` in a child process with pid: %s using %s to output %s\",\n                self._path,\n                self.process.pid,\n                self.creation_flags,\n                self.log_output,\n            )\n        except TypeError:\n            raise\n        except OSError as err:\n            if err.errno == errno.EACCES:\n>               raise WebDriverException(\n                    f\"'{os.path.basename(self._path)}' executable may have wrong permissions.\"\n                ) from err\nE               selenium.common.exceptions.WebDriverException: Message: 'chromedriver.exe' executable may have wrong permissions.\n\n..\\..\\..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\selenium\\webdriver\\common\\service.py:230: WebDriverException\n", "test_name": "test_uno", "rerun": "0"}}, "suite_name": "Asserts_4.py"}}}, "date": "May 24, 2024", "start_time": 1716558032.1673007, "total_suite": 1, "status": "FAIL", "status_list": {"pass": "0", "fail": "0", "skip": "0", "error": "1", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "1"}